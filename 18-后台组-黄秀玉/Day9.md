### 多线程   
1. 进程：是一个正在执行中的程序。每一个进程在执行时都有一个执行顺序，该顺序是一个执行路径或者叫控制单元。  
2. 线程：进程中一个独立的控制单元。线程在控制着进程的执行。一个进程中至少有一个线程。
3. Java VM启动的时候会有一个java.exe进程，该进程至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main方法中，该线程称为主线程。   

---

#### **创建自定义线程的方法之一：继承Thread类**    
步骤：  
1. 定义类继承Thread类。
2. 复写Thread类中run方法。
3. 调用线程的start方法，该方法有两个作用：启动线程，调用run方法。

#### **创建自定义线程的方法之二：实现Runnable接口**    
步骤：   
1. 定义类实现Runnable接口。 
2. 覆盖Runnable接口中的run方法。
3. 通过Thread类建立线程对象。
4. 将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。
5. 调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。

---

**实现方式好处:**
避免了单继承的局限性。

**创建线程的两种方法的区别:**     
继承方法：线程代码存放在Thread子类run方法中。     
实现方法：线程代码存放在接口的子类run方法中。

**多线程的特性之一：随机性。**    
1. 每次运行的执行结果不一样，是因为多个线程都获取CPU的执行权，CPU执行到哪，谁就运行。       
2. 在某个时刻只有一个程序在运行（多核除外）。    

设置线程名称：setName或者构造函数。

---

#### Thread类中的方法：  
1. **public void run()**   
是Thread类中定义的一个用于存储线程要运行的代码的方法。   
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。  
2. **void start()**   
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 

3. **static Thread currentThread()**  
返回对当前正在执行的线程对象的引用。

4. **String getName()**   
返回该线程的名称。   

5. **void setName(String name)**  
改变线程名称，使之与参数 name 相同。  

6. **void setDaemon(boolean on)**    
将该线程标记为守护线程或用户线程。

7. **String toString()**       
返回该线程的字符串表示形式，包括线程名称、优先级和线程组。

8. **setPriority(int newPriority)**   
更改线程的优先级。

9. **void interrupt()**  
中断线程。

10. **static void yield()**  
暂停当前正在执行的线程对象，并执行其他线程。


---

#### 线程四种运行状态  
被创建、运行、冻结、消亡  
一个特殊的状态：就绪。具备了执行资格但是没有获取资源。

---

#### 多线程的安全问题  
1. 原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，另一个线程就参与进来执行，导致共享数据的错误。    
2. 利用**同步代码块**解决这个问题：
synchronized(对象)
{
    需要被同步的代码
}
3. 同步的前提：
- 必须要有两个或者两个以上的线程。
- 必须是多个线程使用同一个对象。
- 必须保证同步中只能有一个线程在运行。  
4. 此方法解决了安全问题也产生了消耗资源的弊端。
5. 同步函数的锁是this，静态同步函数使用的锁是该方法所在类的字节码文件对象，即类名.class。

---

### 线程间通信 
##### wait()、notify()、notifyAll()定义在Object类中的原因？  

- 这些方法存在于同步中  
- 使用这些方法时必须要标识所属的同步的锁  
- 锁可以是任意对象，所以任意对象调用的方法一定定义在Object类中。   

##### wait()、sleep()的区别？   

wait()：释放资源，释放锁。    
sleep()：释放资源，不释放锁。  

##### 等待唤醒机制    
只有同一个锁上的被等待线程可以被同一个锁的notify唤醒，不可以对不同锁中的线程进行唤醒。即等待和唤醒必须是同一个锁。    
##### 停止线程的方法
- 定义循环结束标记
- 使用interrupt方法，结束线程的冻结状态，使线程回到运行状态中来。 
- 注：stop方法已过时，不再使用。
