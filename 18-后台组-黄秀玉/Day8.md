### 匿名内部类   
1. 匿名内部类是内部类的简写格式，是一个匿名子类对象。
2. 定义匿名内部类的前提：内部类必须继承一个类或者实现一个接口。
3. 匿名内部类的格式：new 父类或者接口（）{定义子类的内容}
4. 匿名内部类中定义的方法最好不要超过3个。

### 异常   
**是对问题的描述，将问题进行对象的封装。**   
1. **异常体系的特点：** 异常体系中的所有类以及建立的对象都具备可抛性即可以被throw和throws关键字所操作。   
2. **throw和throws的用法：**
- throw定义在函数内，用于抛出异常对象。  
- throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开的异常类。
3. 当函数内容有throw抛出异常对象，并未进行try处理，必须在函数上进行声明，否则编译失败。注：RuntimeException类除外。
4. **两种异常：**
- 编译时异常
- 运行时异常 (RuntimeException及其子类)
5. **异常处理语句**
- try{} catch(){}
- try{} catch(){} finally{}
- try{} finally{}
6. **finally代码块：** 定义一定执行的代码。通常用于关闭资源。  
当执行到System.exit(0);时finally不会执行。  
7. **自定义异常**   定义类继承Exception或者RuntimeException 
- 为了让该类自定义类具备可抛性。  
- 让该类具备操作异常的共性方法。
8. **异常的好处**     
- 将问题进行封装。
- 将正常流程代码和问题处理代码相分离，方便于阅读。     

9. **异常处理原则** 
- 两种处理方式:try和throw
- 调用到抛出异常的功能时，抛出几个，就处理几个，一个try可以对应多个catch。
- 多个catch，父类的catch放到最下面。
- catch内，需要定义针对性的处理方式。当捕获到本功能处理不了的异常时，可以继续抛出该异常。
- 如果没有catch就代表异常没有被处理过，此时如果是编译时异常，则必须在函数上声明。

  


### 特殊异常类RuntimeException    
1. 自定义异常时，如果该异常发生，无法再继续进行运算，就让自定义异常类继承RuntimeException类。  
2. RuntimeException的直接子类有：NullPointerException（空指针异常）、IndexOutOfBoundsException（角标越界异常）等。   
3. 如果在函数内抛出该异常，函数上可以不用声明，编译可以通过。   
**原因：** 不需要调用者处理该异常情况。在运行时，出现了无法继续进行运算的情况，该异常发生，程序停止运行，调用者可对代码进行修正。
4. 如果在函数上声明了该异常，调用者可以不进行处理，编译也可以通过。
5. 类Object>类Throwable>类Exception>类RuntimeException

### 包    

- 定义包用 package,需要写在代码的第一行。
- 对类文件进行分层管理，给类提供多层命名空间。
- NoClassDefFoundError：没有找到这样的类 
- 类名的全称是包名.类名
- javac -d . 类名.java   
  .代表在当前目录下建立包文件夹 
- javac -d 指定目录 类名.java
- 包的出现使类的运行文件和源文件相分离。
- 包也是一种封装形式。

**包与包之间的访问**   
- 一个包中的类要被访问，必须要有足够大的权限，所以被访问的类要被public访问。同样，类的成员也需要是公有的。
- 不同包中的子类可以直接访问父类中被protected修饰的成员。 
- 包与包之间的访问权限只有两种：public和protected。  

**导入import**    
为了简化类名的书写，导入的是包中的类。  
导入不同包中的类而类名重名时，必须加包名。  

**jar包**   
java的压缩包   
- 方便于使用，只要在classpath设置jar路径即可。
- 数据库驱动，SSH框架都是以jar包体现的。
